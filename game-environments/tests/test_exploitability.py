"""Tests for exploitability computation and empirical strategies.

Covers:
- EmpiricalStrategy extraction from game history
- Exploitability = 0 for NE strategies
- Exploitability > 0 for dominated strategies
- Best response oracle
- Game-based exploitability computation
"""

from __future__ import annotations

import numpy as np
import pytest

from game_envs.analysis.exploitability import (
    EmpiricalStrategy,
    ExploitabilityResult,
    compute_best_response,
    compute_exploitability,
    compute_exploitability_from_game,
)
from game_envs.analysis.nash_solver import NashSolver
from game_envs.core.state import RoundResult
from game_envs.games.prisoners_dilemma import PDConfig, PrisonersDilemma

# PD payoff matrices
PD_P1 = np.array([[3.0, 0.0], [5.0, 1.0]])
PD_P2 = np.array([[3.0, 5.0], [0.0, 1.0]])


class TestEmpiricalStrategy:
    """Tests for EmpiricalStrategy data model."""

    def test_from_history_basic(self) -> None:
        """Extract strategy from simple history."""
        history = [
            RoundResult(0, {"p0": "cooperate", "p1": "defect"}, {"p0": 0.0, "p1": 5.0}),
            RoundResult(1, {"p0": "cooperate", "p1": "defect"}, {"p0": 0.0, "p1": 5.0}),
            RoundResult(2, {"p0": "defect", "p1": "defect"}, {"p0": 1.0, "p1": 1.0}),
        ]
        es = EmpiricalStrategy.from_history(history, "p0")
        assert es.action_frequencies["cooperate"] == pytest.approx(
            2 / 3,
        )
        assert es.action_frequencies["defect"] == pytest.approx(
            1 / 3,
        )

    def test_from_history_uniform(self) -> None:
        """Equal action counts produce uniform distribution."""
        history = [
            RoundResult(0, {"p0": "a"}, {"p0": 1.0}),
            RoundResult(1, {"p0": "b"}, {"p0": 1.0}),
            RoundResult(2, {"p0": "c"}, {"p0": 1.0}),
        ]
        es = EmpiricalStrategy.from_history(history, "p0")
        for freq in es.action_frequencies.values():
            assert freq == pytest.approx(1 / 3)

    def test_from_history_single_action(self) -> None:
        """All same action produces pure strategy."""
        history = [RoundResult(i, {"p0": "defect"}, {"p0": 1.0}) for i in range(10)]
        es = EmpiricalStrategy.from_history(history, "p0")
        assert es.action_frequencies["defect"] == pytest.approx(
            1.0,
        )

    def test_from_history_empty_raises(self) -> None:
        with pytest.raises(ValueError, match="empty"):
            EmpiricalStrategy.from_history([], "p0")

    def test_from_history_missing_player_raises(self) -> None:
        history = [
            RoundResult(0, {"p1": "defect"}, {"p1": 1.0}),
        ]
        with pytest.raises(ValueError, match="not found"):
            EmpiricalStrategy.from_history(history, "p0")

    def test_to_array(self) -> None:
        """Convert frequencies to aligned numpy array."""
        es = EmpiricalStrategy(
            action_frequencies={"cooperate": 0.7, "defect": 0.3},
        )
        arr = es.to_array(["cooperate", "defect"])
        np.testing.assert_array_almost_equal(arr, [0.7, 0.3])

    def test_to_array_missing_action(self) -> None:
        """Missing actions get 0 probability."""
        es = EmpiricalStrategy(
            action_frequencies={"cooperate": 1.0},
        )
        arr = es.to_array(["cooperate", "defect"])
        np.testing.assert_array_almost_equal(arr, [1.0, 0.0])

    def test_serialization(self) -> None:
        es = EmpiricalStrategy(
            action_frequencies={"a": 0.5, "b": 0.5},
        )
        d = es.to_dict()
        restored = EmpiricalStrategy.from_dict(d)
        assert restored.action_frequencies == es.action_frequencies


class TestExploitabilityResult:
    """Tests for ExploitabilityResult data model."""

    def test_serialization(self) -> None:
        result = ExploitabilityResult(
            per_player={"player_0": 0.5, "player_1": 0.3},
            total=0.8,
            best_responses={"player_0": "defect"},
        )
        d = result.to_dict()
        restored = ExploitabilityResult.from_dict(d)
        assert restored.total == 0.8
        assert restored.per_player == result.per_player


class TestBestResponse:
    """Tests for best response oracle."""

    def test_best_response_to_cooperate(self) -> None:
        """Best response to cooperate in PD is defect."""
        opponent = np.array([1.0, 0.0])  # Always cooperate
        br_idx, br_payoff = compute_best_response(
            PD_P1,
            opponent,
            player_is_row=True,
        )
        assert br_idx == 1  # Defect
        assert br_payoff == pytest.approx(5.0)

    def test_best_response_to_defect(self) -> None:
        """Best response to defect in PD is also defect."""
        opponent = np.array([0.0, 1.0])  # Always defect
        br_idx, br_payoff = compute_best_response(
            PD_P1,
            opponent,
            player_is_row=True,
        )
        assert br_idx == 1  # Defect
        assert br_payoff == pytest.approx(1.0)

    def test_best_response_to_mixed(self) -> None:
        """Best response to 50/50 mix in PD is defect."""
        opponent = np.array([0.5, 0.5])
        br_idx, br_payoff = compute_best_response(
            PD_P1,
            opponent,
            player_is_row=True,
        )
        assert br_idx == 1  # Defect

    def test_best_response_column_player(self) -> None:
        """Best response for the column player."""
        # Player 2 (column) against player 1 cooperating
        opponent = np.array([1.0, 0.0])
        br_idx, br_payoff = compute_best_response(
            PD_P2.T,
            opponent,
            player_is_row=True,
        )
        assert br_idx == 1  # Defect (column index 1)
        assert br_payoff == pytest.approx(5.0)


class TestComputeExploitability:
    """Tests for exploitability computation."""

    def test_ne_exploitability_zero(self) -> None:
        """NE strategy has exploitability = 0."""
        # NE of PD is (Defect, Defect)
        s1 = np.array([0.0, 1.0])
        s2 = np.array([0.0, 1.0])
        result = compute_exploitability(PD_P1, PD_P2, s1, s2)
        assert result.total == pytest.approx(0.0, abs=1e-10)
        assert result.per_player["player_0"] == pytest.approx(
            0.0,
            abs=1e-10,
        )
        assert result.per_player["player_1"] == pytest.approx(
            0.0,
            abs=1e-10,
        )

    def test_dominated_exploitability_positive(self) -> None:
        """Cooperate-cooperate is exploitable in PD."""
        s1 = np.array([1.0, 0.0])  # Always cooperate
        s2 = np.array([1.0, 0.0])  # Always cooperate
        result = compute_exploitability(PD_P1, PD_P2, s1, s2)
        assert result.total > 0.0
        # Each player gains 2 by deviating (5 - 3 = 2)
        assert result.per_player["player_0"] == pytest.approx(
            2.0,
        )
        assert result.per_player["player_1"] == pytest.approx(
            2.0,
        )
        assert result.total == pytest.approx(4.0)

    def test_mixed_ne_exploitability_zero(self) -> None:
        """Mixed NE of matching pennies has exploitability 0."""
        mp1 = np.array([[1.0, -1.0], [-1.0, 1.0]])
        mp2 = np.array([[-1.0, 1.0], [1.0, -1.0]])
        s1 = np.array([0.5, 0.5])
        s2 = np.array([0.5, 0.5])
        result = compute_exploitability(mp1, mp2, s1, s2)
        assert result.total == pytest.approx(0.0, abs=1e-10)

    def test_exploitability_with_action_names(self) -> None:
        """Action names should be in best_responses."""
        s1 = np.array([1.0, 0.0])
        s2 = np.array([1.0, 0.0])
        result = compute_exploitability(
            PD_P1,
            PD_P2,
            s1,
            s2,
            action_names_1=["cooperate", "defect"],
            action_names_2=["cooperate", "defect"],
        )
        assert result.best_responses["player_0"] == "defect"
        assert result.best_responses["player_1"] == "defect"

    def test_bos_ne_exploitability(self) -> None:
        """Both pure NE of BoS have zero exploitability."""
        bos1 = np.array([[3.0, 0.0], [0.0, 2.0]])
        bos2 = np.array([[2.0, 0.0], [0.0, 3.0]])

        # Pure NE 1: (Opera, Opera)
        result = compute_exploitability(
            bos1,
            bos2,
            np.array([1.0, 0.0]),
            np.array([1.0, 0.0]),
        )
        assert result.total == pytest.approx(0.0, abs=1e-10)

        # Pure NE 2: (Football, Football)
        result = compute_exploitability(
            bos1,
            bos2,
            np.array([0.0, 1.0]),
            np.array([0.0, 1.0]),
        )
        assert result.total == pytest.approx(0.0, abs=1e-10)

    def test_solver_ne_has_zero_exploitability(self) -> None:
        """NE found by solver should have ~0 exploitability."""
        eqs = NashSolver.support_enumeration(PD_P1, PD_P2)
        eq = eqs[0]
        result = compute_exploitability(
            PD_P1,
            PD_P2,
            eq.strategies["player_0"],
            eq.strategies["player_1"],
        )
        assert result.total == pytest.approx(0.0, abs=1e-10)

    def test_rps_ne_exploitability(self) -> None:
        """RPS uniform NE has zero exploitability."""
        rps1 = np.array(
            [
                [0.0, -1.0, 1.0],
                [1.0, 0.0, -1.0],
                [-1.0, 1.0, 0.0],
            ]
        )
        rps2 = -rps1
        s = np.array([1 / 3, 1 / 3, 1 / 3])
        result = compute_exploitability(
            rps1,
            rps2,
            s,
            s,
        )
        assert result.total == pytest.approx(0.0, abs=1e-6)


class TestComputeExploitabilityFromGame:
    """Tests for game-based exploitability computation."""

    def test_pd_game_ne_exploitability(self) -> None:
        """PD game NE should have 0 exploitability."""
        game = PrisonersDilemma(PDConfig(num_rounds=1))
        strategies = {
            "player_0": EmpiricalStrategy(
                action_frequencies={"defect": 1.0},
            ),
            "player_1": EmpiricalStrategy(
                action_frequencies={"defect": 1.0},
            ),
        }
        result = compute_exploitability_from_game(
            game,
            strategies,
        )
        assert result.total == pytest.approx(0.0, abs=1e-10)

    def test_pd_game_dominated_exploitability(self) -> None:
        """Cooperate-cooperate in PD should be exploitable."""
        game = PrisonersDilemma(PDConfig(num_rounds=1))
        strategies = {
            "player_0": EmpiricalStrategy(
                action_frequencies={"cooperate": 1.0},
            ),
            "player_1": EmpiricalStrategy(
                action_frequencies={"cooperate": 1.0},
            ),
        }
        result = compute_exploitability_from_game(
            game,
            strategies,
        )
        assert result.total > 0.0
        assert result.per_player["player_0"] == pytest.approx(
            2.0,
        )

    def test_pd_game_from_history(self) -> None:
        """End-to-end: play game, extract strategy, compute."""
        game = PrisonersDilemma(
            PDConfig(num_rounds=10, seed=42),
        )
        game.reset()

        # Play 10 rounds always cooperating
        for _ in range(10):
            game.step(
                {
                    "player_0": "cooperate",
                    "player_1": "cooperate",
                }
            )

        history = game.history.rounds
        es0 = EmpiricalStrategy.from_history(
            history,
            "player_0",
        )
        es1 = EmpiricalStrategy.from_history(
            history,
            "player_1",
        )
        assert es0.action_frequencies["cooperate"] == pytest.approx(
            1.0,
        )

        # Fresh game for exploitability calculation
        fresh_game = PrisonersDilemma(
            PDConfig(num_rounds=1),
        )
        result = compute_exploitability_from_game(
            fresh_game,
            {"player_0": es0, "player_1": es1},
        )
        # Cooperate-cooperate is exploitable
        assert result.total > 0.0


class TestCrossSolverExploitability:
    """Verify that solver-found NE have ~0 exploitability."""

    def test_support_enum_ne_zero_exploitability(self) -> None:
        """All NE found by support enum should have ~0 exploitability."""
        bos1 = np.array([[3.0, 0.0], [0.0, 2.0]])
        bos2 = np.array([[2.0, 0.0], [0.0, 3.0]])
        eqs = NashSolver.support_enumeration(bos1, bos2)
        for eq in eqs:
            result = compute_exploitability(
                bos1,
                bos2,
                eq.strategies["player_0"],
                eq.strategies["player_1"],
            )
            assert result.total == pytest.approx(
                0.0,
                abs=1e-6,
            )

    def test_lemke_howson_ne_zero_exploitability(self) -> None:
        """Lemke-Howson NE should have ~0 exploitability."""
        rng = np.random.default_rng(99)
        p1 = rng.random((5, 5))
        p2 = rng.random((5, 5))
        eq = NashSolver.lemke_howson(p1, p2)
        result = compute_exploitability(
            p1,
            p2,
            eq.strategies["player_0"],
            eq.strategies["player_1"],
        )
        assert result.total == pytest.approx(
            0.0,
            abs=0.01,
        )

    def test_fictitious_play_ne_low_exploitability(self) -> None:
        """Fictitious play NE should have low exploitability."""
        eq = NashSolver.fictitious_play(
            [PD_P1, PD_P2],
            max_iterations=10000,
            epsilon=0.001,
        )
        result = compute_exploitability(
            PD_P1,
            PD_P2,
            eq.strategies["player_0"],
            eq.strategies["player_1"],
        )
        assert result.total < 0.5

    def test_allc_maximum_exploitability_in_pd(self) -> None:
        """AllC in one-shot PD has maximum exploitability."""
        # AllC strategy
        s_allc = np.array([1.0, 0.0])
        # NE strategy (AllD)
        s_ne = np.array([0.0, 1.0])

        result_allc = compute_exploitability(
            PD_P1,
            PD_P2,
            s_allc,
            s_allc,
        )
        result_ne = compute_exploitability(
            PD_P1,
            PD_P2,
            s_ne,
            s_ne,
        )
        # AllC is more exploitable than NE
        assert result_allc.total > result_ne.total
        # NE has zero exploitability
        assert result_ne.total == pytest.approx(0.0, abs=1e-10)
        # AllC per-player exploitability = T - R = 5 - 3 = 2
        assert result_allc.per_player["player_0"] == pytest.approx(
            2.0,
        )

    def test_exploitability_result_from_dict_missing_best_responses(
        self,
    ) -> None:
        """from_dict handles missing best_responses gracefully."""
        data = {
            "per_player": {"player_0": 1.0, "player_1": 0.5},
            "total": 1.5,
        }
        result = ExploitabilityResult.from_dict(data)
        assert result.total == 1.5
        assert result.best_responses == {}
