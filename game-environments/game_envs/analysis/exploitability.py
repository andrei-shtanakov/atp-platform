"""Exploitability computation and empirical strategy extraction.

Measures how exploitable a strategy profile is by computing
the payoff gap between the current strategy and the best
response to opponents' play.
"""

from __future__ import annotations

from collections import Counter
from dataclasses import dataclass, field
from typing import Any

import numpy as np

from game_envs.core.action import DiscreteActionSpace
from game_envs.core.game import Game
from game_envs.core.state import RoundResult


@dataclass
class EmpiricalStrategy:
    """Strategy extracted from observed game history.

    Represents a mixed strategy as a probability distribution
    over actions derived from how often each action was played.

    Attributes:
        action_frequencies: Action name/value to observed
            frequency (probability).
    """

    action_frequencies: dict[str, float]

    @classmethod
    def from_history(
        cls,
        history: list[RoundResult],
        player_id: str,
    ) -> EmpiricalStrategy:
        """Extract empirical strategy from game history.

        Counts how often each action was played and normalizes
        to a probability distribution.

        Args:
            history: List of round results from a game.
            player_id: Player whose strategy to extract.

        Returns:
            EmpiricalStrategy with normalized frequencies.

        Raises:
            ValueError: If history is empty or player not found.
        """
        if not history:
            raise ValueError("Cannot extract strategy from empty history")

        actions: list[Any] = []
        for rr in history:
            if player_id in rr.actions:
                actions.append(str(rr.actions[player_id]))

        if not actions:
            raise ValueError(f"Player '{player_id}' not found in history")

        counts = Counter(actions)
        total = sum(counts.values())
        frequencies = {action: count / total for action, count in counts.items()}
        return cls(action_frequencies=frequencies)

    def to_array(
        self,
        action_list: list[str],
    ) -> np.ndarray:
        """Convert to numpy array aligned with action list.

        Args:
            action_list: Ordered list of all possible actions.

        Returns:
            Probability vector matching the action ordering.
        """
        probs = np.zeros(len(action_list))
        for i, action in enumerate(action_list):
            probs[i] = self.action_frequencies.get(
                str(action),
                0.0,
            )
        total = probs.sum()
        if total > 0:
            probs /= total
        return probs

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "action_frequencies": dict(self.action_frequencies),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
    ) -> EmpiricalStrategy:
        """Deserialize from dictionary."""
        return cls(
            action_frequencies=data["action_frequencies"],
        )


@dataclass
class ExploitabilityResult:
    """Results of exploitability computation.

    Attributes:
        per_player: Exploitability gap per player (how much
            they could gain by switching to best response).
        total: Sum of per-player exploitability.
        best_responses: Best response action for each player.
    """

    per_player: dict[str, float]
    total: float
    best_responses: dict[str, Any] = field(
        default_factory=dict,
    )

    def to_dict(self) -> dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "per_player": dict(self.per_player),
            "total": self.total,
            "best_responses": dict(self.best_responses),
        }

    @classmethod
    def from_dict(
        cls,
        data: dict[str, Any],
    ) -> ExploitabilityResult:
        """Deserialize from dictionary."""
        return cls(
            per_player=data["per_player"],
            total=data["total"],
            best_responses=data.get("best_responses", {}),
        )


def compute_best_response(
    payoff_matrix: np.ndarray,
    opponent_strategy: np.ndarray,
    player_is_row: bool = True,
) -> tuple[int, float]:
    """Find best response action for a player.

    For discrete action games, computes the pure strategy
    best response against an opponent's mixed strategy.

    Args:
        payoff_matrix: (m x n) payoff matrix for the player.
        opponent_strategy: Opponent's mixed strategy vector.
        player_is_row: If True, player chooses rows and
            opponent chooses columns. If False, reversed.

    Returns:
        Tuple of (best action index, expected payoff).
    """
    if player_is_row:
        expected = payoff_matrix @ opponent_strategy
    else:
        expected = payoff_matrix.T @ opponent_strategy

    best_action = int(np.argmax(expected))
    best_payoff = float(expected[best_action])
    return best_action, best_payoff


def compute_exploitability(
    payoff_1: np.ndarray,
    payoff_2: np.ndarray,
    strategy_1: np.ndarray,
    strategy_2: np.ndarray,
    action_names_1: list[str] | None = None,
    action_names_2: list[str] | None = None,
) -> ExploitabilityResult:
    """Compute exploitability of a strategy profile.

    Exploitability measures how much each player could gain
    by switching to their best response. For a Nash equilibrium,
    exploitability is 0.

    Args:
        payoff_1: (m x n) payoff matrix for player 1.
        payoff_2: (m x n) payoff matrix for player 2.
        strategy_1: Player 1's mixed strategy (length m).
        strategy_2: Player 2's mixed strategy (length n).
        action_names_1: Optional action names for player 1.
        action_names_2: Optional action names for player 2.

    Returns:
        ExploitabilityResult with per-player gaps.
    """
    # Current expected payoffs
    current_p1 = float(strategy_1 @ payoff_1 @ strategy_2)
    current_p2 = float(strategy_1 @ payoff_2 @ strategy_2)

    # Best response for player 1 (fix player 2's strategy)
    br1_idx, br1_payoff = compute_best_response(
        payoff_1,
        strategy_2,
        player_is_row=True,
    )

    # Best response for player 2 (fix player 1's strategy)
    br2_idx, br2_payoff = compute_best_response(
        payoff_2.T,
        strategy_1,
        player_is_row=True,
    )

    gap_1 = max(0.0, br1_payoff - current_p1)
    gap_2 = max(0.0, br2_payoff - current_p2)

    br_names: dict[str, Any] = {}
    if action_names_1:
        br_names["player_0"] = action_names_1[br1_idx]
    else:
        br_names["player_0"] = br1_idx
    if action_names_2:
        br_names["player_1"] = action_names_2[br2_idx]
    else:
        br_names["player_1"] = br2_idx

    return ExploitabilityResult(
        per_player={
            "player_0": gap_1,
            "player_1": gap_2,
        },
        total=gap_1 + gap_2,
        best_responses=br_names,
    )


def compute_exploitability_from_game(
    game: Game,
    empirical_strategies: dict[str, EmpiricalStrategy],
) -> ExploitabilityResult:
    """Compute exploitability using a Game object.

    Extracts payoff matrices from a discrete-action game and
    computes exploitability for the given empirical strategies.

    Args:
        game: A 2-player discrete-action game.
        empirical_strategies: Empirical strategy per player.

    Returns:
        ExploitabilityResult with per-player gaps.

    Raises:
        ValueError: If game is not 2-player or not discrete.
    """
    players = game.player_ids
    if len(players) != 2:
        raise ValueError("Game exploitability requires exactly 2 players")

    p0, p1 = players[0], players[1]
    space_0 = game.action_space(p0)
    space_1 = game.action_space(p1)

    if not isinstance(space_0, DiscreteActionSpace):
        raise ValueError(f"Player {p0} must have DiscreteActionSpace")
    if not isinstance(space_1, DiscreteActionSpace):
        raise ValueError(f"Player {p1} must have DiscreteActionSpace")

    actions_0 = space_0.to_list()
    actions_1 = space_1.to_list()
    m, n = len(actions_0), len(actions_1)

    # Build payoff matrices by simulating each action pair
    payoff_1 = np.zeros((m, n))
    payoff_2 = np.zeros((m, n))

    for i, a0 in enumerate(actions_0):
        for j, a1 in enumerate(actions_1):
            game.reset()
            result = game.step({p0: a0, p1: a1})
            payoff_1[i, j] = result.payoffs[p0]
            payoff_2[i, j] = result.payoffs[p1]

    # Convert empirical strategies to arrays
    strat_1 = empirical_strategies[p0].to_array([str(a) for a in actions_0])
    strat_2 = empirical_strategies[p1].to_array([str(a) for a in actions_1])

    return compute_exploitability(
        payoff_1,
        payoff_2,
        strat_1,
        strat_2,
        action_names_1=[str(a) for a in actions_0],
        action_names_2=[str(a) for a in actions_1],
    )
