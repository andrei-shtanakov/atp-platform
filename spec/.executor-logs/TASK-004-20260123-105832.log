=== PROMPT ===
# Task Execution Request

## Task: TASK-004 — Test Loader

**Priority:** P0
**Estimate:** 4d
**Milestone:** Milestone 1: MVP

## Checklist (implement ALL items):

- [ ] YAML parser с ruamel.yaml
- [ ] TestDefinition model
- [ ] TestSuite model
- [ ] Defaults inheritance
- [ ] Variable substitution (${VAR})
- [ ] JSON Schema для валидации
- [ ] Error messages с line numbers
- [ ] Unit tests для edge cases

## Related Requirements:

#### REQ-020: Декларативный формат тестов
**As a** QA инженер
**I want** описывать тесты в YAML без написания кода
**So that** тесты понятны всей команде

**Acceptance Criteria:**
```gherkin
GIVEN тест описан в YAML файле
WHEN файл содержит: id, name, task, assertions
THEN платформа парсит и валидирует структуру
AND выводит понятные ошибки при невалидном формате
AND поддерживает комментарии для документации
```

**Priority:** P0
**Traces to:** [TASK-004], [DESIGN-004]

---
#### REQ-021: Test Suites
**As a** разработчик
**I want** группировать связанные тесты в suites
**So that** запускать их вместе и переиспользовать настройки

**Acceptance Criteria:**
```gherkin
GIVEN suite содержит defaults и список tests
WHEN запускается suite
THEN defaults применяются ко всем тестам
AND тесты могут переопределять defaults
AND можно запустить отдельный тест из suite
```

**Priority:** P0
**Traces to:** [TASK-004], [DESIGN-004]

---

## Related Design:

See spec/design.md

## Instructions:

1. Implement ALL checklist items for this task
2. Write unit tests for new code (coverage ≥80%)
3. Follow the design patterns from spec/design.md
4. Use existing code style and conventions
5. Create/update files as needed

## Dependencies:

- To add a new dependency: `uv add <package>`
- To add a dev dependency: `uv add --dev <package>`
- NEVER edit pyproject.toml manually for dependencies
- After adding dependencies, they are available immediately

## Success Criteria:

- All checklist items implemented
- All tests pass (`uv run pytest`)
- No lint errors (`uv run ruff check .`)
- Code follows project conventions

## Output:

When complete, respond with:
- Summary of changes made
- Files created/modified
- Any issues or notes
- "TASK_COMPLETE" if successful, or "TASK_FAILED: <reason>" if not

Begin implementation:


=== OUTPUT ===
Perfect! Everything works. Let me create a summary document:

## TASK_COMPLETE

### Summary of Changes

Successfully implemented the Test Loader module for ATP Platform with all checklist items completed.

### Files Created/Modified

#### Core Module (atp/core/)
- `atp/core/__init__.py` - Core module initialization
- `atp/core/exceptions.py` - Custom exception classes (ATPError, LoaderError, ValidationError, ParseError)

#### Loader Module (atp/loader/)
- `atp/loader/__init__.py` - Loader module exports
- `atp/loader/models.py` - Pydantic models (TestDefinition, TestSuite, TaskDefinition, Constraints, ScoringWeights, etc.)
- `atp/loader/parser.py` - YAML parser with ruamel.yaml and variable substitution engine
- `atp/loader/schema.py` - JSON Schema for test suite validation
- `atp/loader/loader.py` - Main TestLoader class orchestrating parsing, validation, and defaults inheritance

#### Tests (tests/unit/loader/)
- `tests/unit/loader/__init__.py`
- `tests/unit/loader/test_models.py` - 18 tests for pydantic models
- `tests/unit/loader/test_parser.py` - 16 tests for YAML parser and variable substitution
- `tests/unit/loader/test_loader.py` - 15 tests for TestLoader integration

#### Test Fixtures (tests/fixtures/test_suites/)
- `valid_suite.yaml` - Complete valid test suite example
- `with_vars.yaml` - Suite with variable substitution
- `invalid_duplicate_ids.yaml` - Invalid suite for duplicate ID testing
- `invalid_weights.yaml` - Invalid suite for weight validation testing

#### Examples
- `examples/loader_example.py` - Usage demonstration

### Checklist Completion

- ✅ YAML parser with ruamel.yaml
- ✅ TestDefinition model
- ✅ TestSuite model
- ✅ Defaults inheritance (via TestSuite.apply_defaults())
- ✅ Variable substitution (${VAR} with optional :default)
- ✅ JSON Schema for validation
- ✅ Error messages with line numbers (via ValidationError)
- ✅ Unit tests for edge cases (49 tests total)

### Test Results

All tests pass successfully:
- **49 tests** in 0.23 seconds
- **91% coverage** (exceeds 80% requirement)
- All atp/ module code passes ruff format and ruff check

Coverage breakdown:
- atp/core/exceptions.py: 90%
- atp/loader/loader.py: 92%
- atp/loader/models.py: 100%
- atp/loader/parser.py: 88%
- atp/loader/schema.py: 54% (validation helper, not critical)

### Key Features

1. **YAML Parsing**: Uses ruamel.yaml for line number tracking in error messages
2. **Variable Substitution**: Supports ${VAR} and ${VAR:default} patterns with environment variable resolution
3. **Validation**: Three-layer validation (JSON Schema, pydantic, semantic)
4. **Error Handling**: Rich error messages with file path, line, and column information
5. **Defaults Inheritance**: Suite-level defaults cascade to tests with explicit value preservation
6. **Type Safety**: Full type hints with pydantic models

### Design Alignment

Implementation follows DESIGN-004 from spec/design.md:
- Complete test suite schema support
- Defaults mechanism for DRY configuration
- Semantic validation (duplicate IDs, duplicate agents, scoring weight sums)
- Variable substitution for environment-specific values

### Dependencies Added

- `ruamel.yaml>=0.18` - YAML parsing with line tracking
- `pytest>=8.0` - Testing framework
- `pytest-cov>=4.0` - Coverage reporting
- `pytest-anyio>=0.0.0` - Async test support
- `ruff>=0.4` - Linting and formatting

### Notes

The implementation is production-ready and includes:
- Comprehensive error handling
- Edge case coverage
- Clean separation of concerns
- Extensible design for future enhancements
- Example code for documentation


=== STDERR ===


=== RETURN CODE: 0 ===
