"""Tests for ExploitabilityEvaluator."""

import pytest

from atp_games.evaluators.exploitability_evaluator import (
    ExploitabilityConfig,
    ExploitabilityEvaluator,
)
from atp_games.models import EpisodeResult, GameResult, GameRunConfig

# Standard PD payoff matrices (R=3, S=0, T=5, P=1)
# Actions: cooperate=0, defect=1
PD_PAYOFF_1 = [[3.0, 0.0], [5.0, 1.0]]
PD_PAYOFF_2 = [[3.0, 5.0], [0.0, 1.0]]
PD_ACTIONS = ["cooperate", "defect"]


def _make_result_with_actions(
    actions_per_episode: list[list[dict[str, str]]],
    payoffs_per_episode: list[dict[str, float]] | None = None,
) -> GameResult:
    """Create GameResult with action history.

    Args:
        actions_per_episode: List of episodes, each a list
            of round action dicts.
        payoffs_per_episode: Optional final payoffs per
            episode.
    """
    episodes: list[EpisodeResult] = []
    for i, rounds in enumerate(actions_per_episode):
        actions_log = [
            {
                "round_number": j,
                "actions": actions,
                "payoffs": {},
            }
            for j, actions in enumerate(rounds)
        ]
        payoffs = (
            payoffs_per_episode[i]
            if payoffs_per_episode
            else {"player_0": 0.0, "player_1": 0.0}
        )
        episodes.append(
            EpisodeResult(
                episode=i,
                payoffs=payoffs,
                actions_log=actions_log,
            )
        )
    return GameResult(
        game_name="PD",
        config=GameRunConfig(episodes=len(episodes)),
        episodes=episodes,
        agent_names={"player_0": "agent_a", "player_1": "agent_b"},
    )


class TestExploitabilityBasic:
    def test_name(self) -> None:
        evaluator = ExploitabilityEvaluator()
        assert evaluator.name == "exploitability"

    def test_empty_episodes(self) -> None:
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        result = GameResult(
            game_name="PD",
            config=GameRunConfig(),
        )
        eval_result = evaluator.evaluate_game(result)
        assert not eval_result.passed

    def test_missing_payoff_matrices(self) -> None:
        evaluator = ExploitabilityEvaluator()
        result = _make_result_with_actions(
            [[{"player_0": "cooperate", "player_1": "defect"}]],
            [{"player_0": 0.0, "player_1": 5.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        assert not eval_result.passed
        assert "Payoff matrices required" in (eval_result.checks[0].message or "")


class TestNashEquilibriumExploitability:
    """Exploitability should be ~0 for Nash equilibrium play."""

    def test_mutual_defection_ne(self) -> None:
        """AllD vs AllD is NE in one-shot PD.

        Both players play defect with probability 1.
        Exploitability should be 0.
        """
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                epsilon=0.15,
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        # 10 rounds of mutual defection
        rounds = [{"player_0": "defect", "player_1": "defect"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 10.0, "player_1": 10.0}],
        )
        eval_result = evaluator.evaluate_game(result)

        # Should pass — NE has 0 exploitability
        total_check = next(
            c for c in eval_result.checks if c.name == "total_exploitability"
        )
        assert total_check.passed
        assert total_check.details is not None
        assert total_check.details["total"] == pytest.approx(0.0, abs=1e-6)

    def test_ne_per_player_zero(self) -> None:
        """Per-player exploitability is 0 at NE."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "defect", "player_1": "defect"} for _ in range(20)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 20.0, "player_1": 20.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        per_player_check = next(
            c for c in eval_result.checks if c.name == "per_player_exploitability"
        )
        assert per_player_check.passed
        assert per_player_check.details is not None
        assert per_player_check.details["per_player"]["player_0"] == pytest.approx(
            0.0, abs=1e-6
        )
        assert per_player_check.details["per_player"]["player_1"] == pytest.approx(
            0.0, abs=1e-6
        )


class TestAllCExploitability:
    """AllC is highly exploitable in PD."""

    def test_allc_vs_allc_exploitable(self) -> None:
        """AllC vs AllC: each can gain by switching to D.

        Current payoff = 3 (R).
        Best response = defect → payoff 5 (T).
        Exploitability per player = 5 - 3 = 2.
        """
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                epsilon=0.15,
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        eval_result = evaluator.evaluate_game(result)

        # Should fail — AllC is exploitable
        total_check = next(
            c for c in eval_result.checks if c.name == "total_exploitability"
        )
        assert not total_check.passed
        assert total_check.details is not None
        # Total exploitability = 2 + 2 = 4
        assert total_check.details["total"] == pytest.approx(4.0, abs=0.01)

    def test_allc_per_player_exploitability(self) -> None:
        """Each player has exploitability = 2 when both AllC."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        per_player_check = next(
            c for c in eval_result.checks if c.name == "per_player_exploitability"
        )
        assert not per_player_check.passed
        assert per_player_check.details is not None
        assert per_player_check.details["per_player"]["player_0"] == pytest.approx(
            2.0, abs=0.01
        )
        assert per_player_check.details["per_player"]["player_1"] == pytest.approx(
            2.0, abs=0.01
        )

    def test_allc_best_response_is_defect(self) -> None:
        """Best response to AllC is Defect."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        per_player_check = next(
            c for c in eval_result.checks if c.name == "per_player_exploitability"
        )
        assert per_player_check.details is not None
        br = per_player_check.details["best_responses"]
        assert br["player_0"] == "defect"
        assert br["player_1"] == "defect"


class TestMixedStrategies:
    def test_mixed_strategy_exploitability(self) -> None:
        """A mixed strategy: 50% C, 50% D."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                epsilon=3.0,  # generous threshold
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        # 50/50 mixed strategy
        rounds = [
            {"player_0": "cooperate", "player_1": "cooperate"},
            {"player_0": "defect", "player_1": "defect"},
        ] * 5
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 20.0, "player_1": 20.0}],
        )
        eval_result = evaluator.evaluate_game(result)

        # Exploitability should be > 0 but less than AllC
        total_check = next(
            c for c in eval_result.checks if c.name == "total_exploitability"
        )
        assert total_check.details is not None
        total = total_check.details["total"]
        assert total > 0.0  # Not NE
        assert total < 4.0  # Less than AllC


class TestMultiEpisode:
    def test_aggregate_across_episodes(self) -> None:
        """Strategies extracted across all episodes."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        # Episode 0: all defect, Episode 1: all defect
        result = _make_result_with_actions(
            [
                [{"player_0": "defect", "player_1": "defect"}] * 5,
                [{"player_0": "defect", "player_1": "defect"}] * 5,
            ],
            [
                {"player_0": 5.0, "player_1": 5.0},
                {"player_0": 5.0, "player_1": 5.0},
            ],
        )
        eval_result = evaluator.evaluate_game(result)
        total_check = next(
            c for c in eval_result.checks if c.name == "total_exploitability"
        )
        assert total_check.passed
        assert total_check.details is not None
        assert total_check.details["total"] == pytest.approx(0.0, abs=1e-6)


class TestConfigOverride:
    def test_override_epsilon(self) -> None:
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                epsilon=0.01,
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        # With tight epsilon, AllC should fail
        eval_result = evaluator.evaluate_game(result)
        assert not eval_result.passed

        # Override with generous epsilon
        eval_result_2 = evaluator.evaluate_game(
            result,
            config={
                "epsilon": 5.0,
                "payoff_matrix_1": PD_PAYOFF_1,
                "payoff_matrix_2": PD_PAYOFF_2,
                "action_names_1": PD_ACTIONS,
                "action_names_2": PD_ACTIONS,
            },
        )
        total_check = next(
            c for c in eval_result_2.checks if c.name == "total_exploitability"
        )
        assert total_check.passed


class TestEmpiricalStrategySummary:
    def test_strategy_details_present(self) -> None:
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [
            {"player_0": "defect", "player_1": "cooperate"},
            {"player_0": "defect", "player_1": "cooperate"},
            {"player_0": "cooperate", "player_1": "cooperate"},
        ]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 13.0, "player_1": 3.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        strategy_check = next(
            c for c in eval_result.checks if c.name == "empirical_strategy"
        )
        assert strategy_check.passed
        assert strategy_check.details is not None
        p0_freq = strategy_check.details["player_0"]["action_frequencies"]
        assert p0_freq["defect"] == pytest.approx(2 / 3)
        assert p0_freq["cooperate"] == pytest.approx(1 / 3)


class TestExploitabilityScoring:
    def test_score_1_at_ne(self) -> None:
        """Score should be 1.0 at Nash equilibrium."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "defect", "player_1": "defect"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 10.0, "player_1": 10.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        assert eval_result.score == pytest.approx(1.0)

    def test_score_low_for_exploitable(self) -> None:
        """Score should be < 1 for exploitable strategy."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                epsilon=0.15,
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        assert eval_result.score < 1.0

    def test_all_check_scores_bounded(self) -> None:
        """All check scores are between 0 and 1."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        rounds = [{"player_0": "cooperate", "player_1": "cooperate"} for _ in range(10)]
        result = _make_result_with_actions(
            [rounds],
            [{"player_0": 30.0, "player_1": 30.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        for check in eval_result.checks:
            assert 0.0 <= check.score <= 1.0, (
                f"Check '{check.name}' score={check.score} out of bounds"
            )


class TestEdgeCases:
    def test_single_round(self) -> None:
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        result = _make_result_with_actions(
            [[{"player_0": "defect", "player_1": "defect"}]],
            [{"player_0": 1.0, "player_1": 1.0}],
        )
        eval_result = evaluator.evaluate_game(result)
        assert eval_result.passed

    def test_three_players_rejected(self) -> None:
        """Exploitability only works for 2-player games."""
        evaluator = ExploitabilityEvaluator(
            config=ExploitabilityConfig(
                payoff_matrix_1=PD_PAYOFF_1,
                payoff_matrix_2=PD_PAYOFF_2,
                action_names_1=PD_ACTIONS,
                action_names_2=PD_ACTIONS,
            ),
        )
        result = GameResult(
            game_name="3-player",
            config=GameRunConfig(),
            episodes=[
                EpisodeResult(
                    episode=0,
                    payoffs={
                        "p0": 1.0,
                        "p1": 1.0,
                        "p2": 1.0,
                    },
                    actions_log=[
                        {
                            "round_number": 0,
                            "actions": {
                                "p0": "a",
                                "p1": "b",
                                "p2": "c",
                            },
                            "payoffs": {},
                        }
                    ],
                ),
            ],
        )
        eval_result = evaluator.evaluate_game(result)
        assert not eval_result.passed
        assert "2 players" in (eval_result.checks[0].message or "")
